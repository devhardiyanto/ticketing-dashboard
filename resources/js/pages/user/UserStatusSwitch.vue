<script setup lang="ts">
import { Switch } from '@/components/ui/switch';
import { useForm } from '@inertiajs/vue3';
import { ref, watch } from 'vue';
import { toast } from 'vue-sonner';
import userRoute from '@/routes/user';

const props = defineProps<{
  userId: string | number;
  status: string;
}>();

// State management
const isChecked = ref(props.status === 'active');
const isLoading = ref(false);

// Sync if data table refreshes
watch(() => props.status, (newVal) => {
  isChecked.value = newVal === 'active';
});

const form = useForm({});

// Handler logic
const onCheckedChange = (checked: boolean) => {
  if (isLoading.value) return;

  // Optimistic Update
  const previousState = isChecked.value;
  isChecked.value = checked;
  isLoading.value = true;

  // Hit API
  // userRoute.toggleStatus(id) - assuming format generated by wayfinder
  // Note: Route name is "user.toggle-status", so wayfinder should generate user.toggleStatus() ??
  // Or user.toggle_status() ?? usually camelCase.
  // Let's assume standard wayfinder behavior converts kebab-case route name suffix to camelCase method.
  // Route name: "user.toggle-status" -> user.toggleStatus ?
  // Actually wayfinder maps structure.
  // Let's try user.toggleStatus first. If not I'll fix.

  form.patch(userRoute.toggleStatus(props.userId).url, {
    preserveScroll: true,
    onSuccess: () => {
      isLoading.value = false;
      toast.success(`User ${checked ? 'activated' : 'deactivated'}`);
    },
    onError: () => {
      isChecked.value = previousState;
      isLoading.value = false;
      toast.error('Failed to update status');
    }
  });
};
</script>

<template>
  <div class="flex items-center space-x-2" @click.stop>
    <Switch
      :model-value="isChecked"
      :disabled="isLoading || form.processing"
      @update:model-value="onCheckedChange"
    />
  </div>
</template>
